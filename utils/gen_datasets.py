from utils.tools.general import *
from .datasets import *
from utils.paster.create_datasets import LoadProductWithNoise
from utils.paster.paster import DebugPaster

class GenImageWithLoader(LoadImagesAndLabels):
    def __init__(self, bimg_paths, mixed_coco, root_save_dir,  path, img_size=640, batch_size=16, augment=False, hyp=None, rect=False, image_weights=False, cache_images=False, single_cls=False, stride=32, pad=0, prefix=''):
        super().__init__(path, img_size=img_size, batch_size=batch_size, augment=augment, hyp=hyp, rect=rect, image_weights=image_weights, cache_images=cache_images, single_cls=single_cls, stride=stride, pad=pad, prefix=prefix)
        root_save_dir = Path(root_save_dir)

        self.gen_fake_coco = GeneratePasteImage(bimg_paths, mixed_coco, root_save_dir/'images', root_save_dir/'labels', create_dir=True)
        

    def __getitem__(self, index):
        index = self.indices[index]  # linear, shuffled, or image_weights
        self.count += 1
        hyp = self.hyp
        mosaic = self.mosaic and random.random() < hyp['mosaic']
        if mosaic:
            # Load mosaic
            img, labels = load_mosaic(self, index)
            shapes = None

            # MixUp augmentation
            if random.random() < hyp['mixup']:
                img, labels = mixup(img, labels, *load_mosaic(self, random.randint(0, self.n - 1)))

        else:
            self.gen_fake_coco.next_batch(method='sample', n=1).save()
            # Load image
            # img, (h0, w0), (h, w) = load_image(self, index)

            # # ---------------- paste ---------------
            # labels = self.labels[index].copy()
            

            # if self.augment and self.paster:

            #     if labels.size:  
            #         labels[:, 1:] = xywhn2xyxy(labels[:, 1:], w, h)
            #     img, labels = self.paster._paste_on_labeled_img(img[...,::-1], labels) #BGR to RGB img
            #     img = img[..., ::-1] #RGB to BGR img
            #     hw_pasted = img.shape
            #     labels[:, 1:] = xyxy2xywhn(labels[:, 1:], hw_pasted[1], hw_pasted[0])

        return np.zeros((0,5))


import uuid
from torch import is_tensor
from typing import Tuple
from utils.tools.bbox import xywhn2xyxy
from utils.tools.bbox import xyxy2xywhn
from utils.tools.image import img_height_width
import imageio


def labels_2_yolo_format(img, labels, copy=True):
    '''convert [cls_id, xyxy! to [cls_id, xywh] format'''
    labels = labels.copy() if copy else labels
    h,w,_ = img.shape
    labels[:, 1:] = xyxy2xywhn(labels[:, 1:], w,h)
    return labels


def write_yolo_label(txt_path, labels: np.array, mode='w'):
    if is_tensor(labels):
        labels = labels.numpy()

    if labels.ndim == 1:
        write_yolo_label_dim1(txt_path, labels, mode)
    elif labels.ndim == 2:
        write_yolo_label_dim2(txt_path, labels)
    else:
        raise ValueError('only numpy array with dimension 1 or 2 is supported')


def write_yolo_label_dim2(txt_path, labels):
    '''only work for 2d array, for 1d array, look for `write_yolo_label_dim1`'''
    np.savetxt(txt_path, labels, delimiter=' ', fmt='%g')
    

def write_yolo_label_dim1(txt_path, line: Tuple, mode='a'):
    line = tuple(line)
    with open(str(txt_path), mode) as f:
        f.write(('%g ' * len(line)).rstrip() % line + '\n')


def load_yolo_labels(txt_path):
    return np.loadtxt(txt_path, delimiter=' ')

def uniq_file_name(prefix=None):
    hex_name = uuid.uuid4().hex
    uniq_name = prefix + hex_name if prefix else  hex_name
    return uniq_name


def write_img_and_labels(img, labels, img_dir, lbl_dir, fname=None, img_ext='.jpg', lbl_ext='.txt'):
    '''This is used to save the img and labels with same name, if filename is not provided, 
    it will be auto generated by uuid4

    Args:
    ----
    img: np.ndarray

    labels: List | np.ndarray | torch.tensor
        expect rank 2 tensor or array ( 2xN ), the labels 
        Eg:
        >> lbls = [[100, 100, 200, 200],
                    [100, 100, 200, 200]]
 
        >> lbls = [[2, 0.5, 0.6, 0.55, 0.43],
                    [3, 0.5, 0.6, 0.55, 0.48]]

    img_dir: Path | str
        directory to save image

    lbl_dir: Path | str
        directory to save label

    fname: str | None (optioal, default=None)
        shared filename for image and label, different suffix will be used

    img_ext: str | None (optioal, default='.jpg')
        image suffix to be saved

    lbl_ext: str | None (optioal, default='.txt')
        label suffix to be saved
    '''

    fname =  str(fname) if fname else uniq_file_name()
    img_name= fname + img_ext
    lbl_name = fname + lbl_ext
    
    imageio.imwrite(img_dir/img_name, img)
    write_yolo_label(lbl_dir/lbl_name, labels)


from utils.tools.image import read_color_img
from utils.tools.general import mkdir_r

def generate_fake_coco_labels(n, back_img_paths, mixed_coco: LoadProductWithNoise, img_dir: Path, lbl_dir: Path, create_dir=False):
    img_dir = Path(img_dir)
    lbl_dir = Path(lbl_dir)
    back_img_paths = pd.Series(back_img_paths).apply(Path)
    if create_dir:
        if not img_dir.is_dir(): mkdir_r(img_dir)
        if not lbl_dir.is_dir(): mkdir_r(lbl_dir)

    for i in tqdm(range(n)):
        img_path = back_img_paths.sample(1).values[0]
        back_img = read_color_img(img_path)
        paster = DebugPaster(back_img, save_mask=True)
        paster.batch_pasting_flow(n=None, coco=mixed_coco, show_pasted_mask=False)

        yolo_labels = labels_2_yolo_format(
            paster.back_img, 
            paster.labels
        )

        write_img_and_labels(paster.back_img, yolo_labels, img_dir, lbl_dir, fname=img_path.stem, img_ext='.jpg', lbl_ext='.txt')
        

class GeneratePasteImage:
    def __init__(self, back_img_paths, mixed_coco: LoadProductWithNoise, img_dir: Path, lbl_dir: Path, create_dir=False) -> None:
        self.img_dir = Path(img_dir)
        self.lbl_dir = Path(lbl_dir)
        self.back_img_paths = pd.Series(back_img_paths).apply(Path)
        if create_dir:
            if not img_dir.is_dir(): mkdir_r(img_dir)
            if not lbl_dir.is_dir(): mkdir_r(lbl_dir)

        self.pasted_img_paths = []
        self.pasted_imgs = []
        self.pasted_lbls = []

        self.coco = mixed_coco

    def _gen_img_labels(self, back_img_path):
        back_img = read_color_img(back_img_path)
        paster = DebugPaster(back_img, save_mask=True)
        paster.batch_pasting_flow(n=None, coco=self.coco, show_pasted_mask=False)

        yolo_labels = labels_2_yolo_format(
            paster.back_img, 
            paster.labels
        )
        return paster.back_img, yolo_labels

    def gen_img_labels(self, back_img_path):
        img, lbl = self._gen_img_labels(back_img_path)
        self.pasted_img_paths.append(back_img_path)
        self.pasted_imgs.append(img)
        self.pasted_lbls.append(lbl)

    def next_batch(self, method, n=None):
        # edit logic here
        if n and method == 'sample':
            back_img_paths = self.back_img_paths.sample(n).values
        elif method == 'all':
            back_img_paths = self.back_img_paths
        else:
            raise ValueError('please provide correct method')


        for img_path in back_img_paths:
            try: 
                self.gen_img_labels(img_path)
            except ValueError as e:
                if 'Only color img allowed' in e.args:
                    print('skip non color img')
                    continue
                else:
                    raise e

        return self

    def save(self):
        for back_img, yolo_labels, img_path in zip(self.pasted_imgs, self.pasted_lbls, self.pasted_img_paths):
            write_img_and_labels(back_img, yolo_labels, self.img_dir, self.lbl_dir, fname=img_path.stem, img_ext='.jpg', lbl_ext='.txt')

